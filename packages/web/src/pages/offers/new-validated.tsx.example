/**
 * EXAMPLE: Offers Create Form with Zod Validation
 *
 * This is an example of how to integrate Zod validation into the offer creation form.
 * Key improvements:
 * 1. Form validation before submission
 * 2. Real-time field validation
 * 3. Better error messages
 * 4. Type safety
 */

import { useState } from 'react';
import { useRouter } from 'next/router';
import { api } from '@/lib/api';
import toast from 'react-hot-toast';
import { useTranslations } from 'next-intl';
import { createOfferSchema, validateFormData, type CreateOfferFormData } from '@/lib/validations';
import { logger } from '@/lib/logger';

export default function NewOfferValidated() {
  const router = useRouter();
  const t = useTranslations('offerCreate');
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});

  // Form state with proper types
  const [formData, setFormData] = useState<Partial<CreateOfferFormData>>({
    title: '',
    description: '',
    type: 'PRODUCT',
    category: '',
    isFree: false,
    tags: [],
    images: [],
  });

  /**
   * Validate a single field on blur
   */
  const validateField = (fieldName: keyof CreateOfferFormData) => {
    const result = createOfferSchema.shape[fieldName]?.safeParse(formData[fieldName]);

    if (result && !result.success) {
      setErrors(prev => ({
        ...prev,
        [fieldName]: result.error.errors[0]?.message || 'Invalid value',
      }));
    } else {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[fieldName];
        return newErrors;
      });
    }
  };

  /**
   * Handle form submission with validation
   */
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setErrors({});

    // Validate entire form
    const validation = validateFormData(createOfferSchema, formData, (errors) => {
      // Show first error as toast
      const firstError = Object.values(errors)[0];
      if (firstError) {
        toast.error(firstError);
      }
    });

    if (!validation.success) {
      setErrors(validation.errors);
      setLoading(false);
      return;
    }

    try {
      // Upload images first
      const imageUrls = await uploadImages(validation.data.images);

      // Prepare validated data
      const offerData = {
        ...validation.data,
        images: imageUrls,
        // Convert tags array to what backend expects
        tags: validation.data.tags,
      };

      const response = await api.post('/offers', offerData);
      toast.success(t('toasts.createSuccess'));
      router.push(`/offers/${response.data.id}`);
    } catch (error: unknown) {
      logger.error('Error creating offer', { error });
      const errorMessage = error instanceof Error && 'response' in error
        ? (error as { response?: { data?: { message?: string } } }).response?.data?.message
        : undefined;
      toast.error(errorMessage || t('toasts.createError'));
    } finally {
      setLoading(false);
    }
  };

  /**
   * Upload images helper
   */
  const uploadImages = async (images: File[]): Promise<string[]> => {
    if (!images.length) return [];

    const formData = new FormData();
    images.forEach((image) => formData.append('files', image));

    try {
      const response = await api.post('/upload', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      });
      return response.data.urls || [];
    } catch (error) {
      logger.error('Error uploading images', { error });
      throw new Error('Failed to upload images');
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {/* Title Field with Validation */}
      <div>
        <label htmlFor="title" className="block text-sm font-medium mb-2">
          Título *
        </label>
        <input
          type="text"
          id="title"
          value={formData.title || ''}
          onChange={(e) => setFormData(prev => ({ ...prev, title: e.target.value }))}
          onBlur={() => validateField('title')}
          className={`w-full px-4 py-2 border rounded-lg ${
            errors.title ? 'border-red-500' : 'border-gray-300'
          }`}
        />
        {errors.title && (
          <p className="mt-1 text-sm text-red-600">{errors.title}</p>
        )}
      </div>

      {/* Description Field with Validation */}
      <div>
        <label htmlFor="description" className="block text-sm font-medium mb-2">
          Descripción *
        </label>
        <textarea
          id="description"
          rows={4}
          value={formData.description || ''}
          onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
          onBlur={() => validateField('description')}
          className={`w-full px-4 py-2 border rounded-lg ${
            errors.description ? 'border-red-500' : 'border-gray-300'
          }`}
        />
        {errors.description && (
          <p className="mt-1 text-sm text-red-600">{errors.description}</p>
        )}
        <p className="mt-1 text-xs text-gray-500">
          {formData.description?.length || 0} / 2000 caracteres
        </p>
      </div>

      {/* Price Fields with Validation */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div>
          <label htmlFor="priceEur" className="block text-sm font-medium mb-2">
            Precio (€)
          </label>
          <input
            type="number"
            id="priceEur"
            min="0"
            step="0.01"
            value={formData.priceEur || ''}
            onChange={(e) => setFormData(prev => ({
              ...prev,
              priceEur: e.target.value ? parseFloat(e.target.value) : undefined
            }))}
            onBlur={() => validateField('priceEur')}
            disabled={formData.isFree}
            className="w-full px-4 py-2 border border-gray-300 rounded-lg"
          />
        </div>

        <div>
          <label htmlFor="priceCredits" className="block text-sm font-medium mb-2">
            Precio (Créditos)
          </label>
          <input
            type="number"
            id="priceCredits"
            min="0"
            value={formData.priceCredits || ''}
            onChange={(e) => setFormData(prev => ({
              ...prev,
              priceCredits: e.target.value ? parseInt(e.target.value) : undefined
            }))}
            onBlur={() => validateField('priceCredits')}
            disabled={formData.isFree}
            className="w-full px-4 py-2 border border-gray-300 rounded-lg"
          />
        </div>

        <div className="flex items-end">
          <label className="flex items-center gap-2">
            <input
              type="checkbox"
              checked={formData.isFree || false}
              onChange={(e) => setFormData(prev => ({ ...prev, isFree: e.target.checked }))}
              className="w-4 h-4"
            />
            <span className="text-sm">Gratis</span>
          </label>
        </div>
      </div>
      {errors.isFree && (
        <p className="mt-1 text-sm text-red-600">{errors.isFree}</p>
      )}

      {/* Submit Button */}
      <button
        type="submit"
        disabled={loading}
        className="w-full bg-blue-600 text-white py-3 px-6 rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
      >
        {loading ? 'Creando...' : 'Crear Oferta'}
      </button>
    </form>
  );
}
